/*
 * Copyright (c) 2008-2015, Compass Plus Limited. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. This Source Code is distributed
 * WITHOUT ANY WARRANTY; including any implied warranties but not limited to
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * Mozilla Public License, v. 2.0. for more details.
 */

package org.radixware.kernel.designer.common.dialogs.chooseobject;

import java.awt.BorderLayout;
import java.awt.Image;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import org.openide.explorer.ExplorerManager;
import org.openide.explorer.view.CheckableNode;
import org.openide.explorer.view.OutlineView;
import org.openide.nodes.AbstractNode;
import org.openide.nodes.Children;
import org.openide.nodes.Node;
import org.openide.nodes.Sheet;
import org.radixware.kernel.common.repository.Branch;
import org.radixware.kernel.common.repository.Layer;


public class ChooseLayerPanel extends javax.swing.JPanel implements ExplorerManager.Provider {

    private final ExplorerManager manager = new ExplorerManager();
    private OutlineView outline = new OutlineView();
    private final Branch branch;
    private Set<Layer> selection = new HashSet<>();

    private Children createLayerNodeChildren(Layer currentLayer, List<Layer> allLayers) {
        boolean test = false;
        for (final Layer layer : allLayers) {
            if (layer.listBaseLayers().contains(currentLayer)) {
                test = true;
                break;
            }
        }
        if (test) {
            return new LayerNodeChildren(currentLayer, allLayers);
        } else {
            return Children.LEAF;
        }
    }

    private class LayerNode extends AbstractNode implements CheckableNode {

        private final Layer currentLayer;

        public LayerNode(Layer currentLayer, List<Layer> allLayers) {
            super(createLayerNodeChildren(currentLayer, allLayers));

            setDisplayName(currentLayer.getName());
            this.currentLayer = currentLayer;
        }

        @Override
        public boolean isCheckable() {
            return true;
        }

        @Override
        public boolean isCheckEnabled() {
            return true;
        }

        @Override
        public Boolean isSelected() {
            return selection.contains(currentLayer);
        }

        @Override
        public void setSelected(Boolean selected) {
            if (selected) {
                selection.add(currentLayer);
            } else {
                selection.remove(currentLayer);
            }
        }

        @Override
        public Image getIcon(int type) {
            return currentLayer.getIcon().getImage();
        }

        @Override
        public Image getOpenedIcon(int type) {
            return getIcon(type);
        }

        public String getURI() {
            return currentLayer.getURI();
        }
    }

    private class LayerNodeChildren extends Children.Array {

        public LayerNodeChildren(Layer currentLayer, List<Layer> allLayers) {
            super();
            this.nodes = calcNodes(currentLayer, allLayers);
        }

        private List<Node> calcNodes(Layer currentLayer, List<Layer> allLayers) {
            final List<Node> child = new LinkedList<>();
            for (final Layer layer : allLayers) {
                if (layer.listBaseLayers().contains(currentLayer)) {
                    child.add(new LayerNode(layer, allLayers));
                }
            }
            return child;
        }
    }

    /**
     * Creates new form ChooseLayerPanel
     */
    public ChooseLayerPanel(Branch branch, Set<Layer> currentValue) {
        this.branch = branch;
        initComponents();
        setLayout(new BorderLayout());
        if (currentValue != null) {
            selection.addAll(currentValue);
        }
        add(outline, BorderLayout.CENTER);
        outline.getOutline().setShowGrid(false);
        outline.getOutline().setRowSelectionAllowed(true);
        outline.getOutline().setColumnHidingAllowed(false);
        outline.getOutline().getColumnModel().getColumn(0).setHeaderValue("");
        getExplorerManager().setRootContext(new LayerNode(findRadix(), branch.getLayers().list()));
    }

    private Layer findRadix() {
        return branch.getLayers().findByURI("org.radixware");
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @Override
    public ExplorerManager getExplorerManager() {
        return this.manager;
    }

    public Set<Layer> selection() {
        return new HashSet<>(selection);
    }

    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
