/*
 * Copyright (c) 2008-2015, Compass Plus Limited. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. This Source Code is distributed
 * WITHOUT ANY WARRANTY; including any implied warranties but not limited to
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * Mozilla Public License, v. 2.0. for more details.
 */

package org.radixware.kernel.reporteditor.common.explorer;

import java.awt.BorderLayout;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.explorer.ExplorerManager;
import org.openide.explorer.view.BeanTreeView;
import org.openide.filesystems.FileObject;
import org.openide.nodes.Children;
import org.openide.nodes.Node;
import org.openide.util.Mutex;
import org.openide.windows.TopComponent;
import org.openide.util.NbBundle.Messages;
import org.radixware.kernel.common.defs.RadixObject;
import org.radixware.kernel.common.defs.ads.localization.AdsLocalizingBundleDef;
import org.radixware.kernel.common.repository.Branch;
import org.radixware.kernel.designer.common.general.filesystem.RadixFileUtil;
import org.radixware.kernel.designer.common.general.nodes.NodesManager;
import org.radixware.kernel.designer.common.general.nodes.hide.Restorable;
import org.radixware.kernel.msdleditor.tree.MsdlSchemesNode;
import org.radixware.kernel.reporteditor.common.Config;
import org.radixware.kernel.reporteditor.common.UserExtensionManager;
import org.radixware.kernel.reporteditor.env.saveall.SaveAllImpl;
import org.radixware.kernel.reporteditor.tree.ReportsNode;
import org.radixware.kernel.roleeditor.tree.UserRolesNode;
import org.radixware.kernel.userextmanager.tree.UserExtensionsNode;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(
        dtd = "-//org.radixware.kernel.reporteditor.common.explorer//UdsExplorer//EN",
        autostore = false)
@TopComponent.Description(
        preferredID = "UdsExplorerTopComponent",
        //iconBase="SET/PATH/TO/ICON/HERE", 
        persistenceType = TopComponent.PERSISTENCE_ALWAYS)
@TopComponent.Registration(mode = "explorer", openAtStartup = true)
@ActionID(category = "Window", id = "org.radixware.kernel.reporteditor.common.explorer.UdsExplorerTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(
        displayName = "#CTL_UdsExplorerAction",
        preferredID = "UdsExplorerTopComponent")
@Messages({
    "CTL_UdsExplorerAction=Definitions Explorer",
    "CTL_UdsExplorerTopComponent=UdsExplorer Window",
    "HINT_UdsExplorerTopComponent=This is a UdsExplorer window"
})
public final class UdsExplorerTopComponent extends TopComponent implements ExplorerManager.Provider, NodesManager.LogicalViewProvider {

    private ExplorerManager explorerManager = new ExplorerManager();
    private BeanTreeView treeView = new BeanTreeView();

    public UdsExplorerTopComponent() {
        initComponents();
        setName(Bundle.CTL_UdsExplorerTopComponent());
        setToolTipText(Bundle.HINT_UdsExplorerTopComponent());
        putClientProperty(TopComponent.PROP_CLOSING_DISABLED, Boolean.TRUE);
        putClientProperty(TopComponent.PROP_DRAGGING_DISABLED, Boolean.TRUE);
        putClientProperty(TopComponent.PROP_MAXIMIZATION_DISABLED, Boolean.TRUE);
        putClientProperty(TopComponent.PROP_SLIDING_DISABLED, Boolean.TRUE);
        putClientProperty(TopComponent.PROP_UNDOCKING_DISABLED, Boolean.TRUE);
        add(treeView, BorderLayout.CENTER);
        explorerManager.addPropertyChangeListener(new PropertyChangeListener() {
            @Override
            public void propertyChange(PropertyChangeEvent e) {
                if (ExplorerManager.PROP_SELECTED_NODES.equals(e.getPropertyName())) {
                    UdsExplorerTopComponent.this.setActivatedNodes(explorerManager.getSelectedNodes());
                }
            }
        });
        this.setDisplayName("Used-Defined Definitions");
        SaveAllImpl.getDefault();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setLayout(new java.awt.BorderLayout());
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    @Override
    public void componentOpened() {
        // TODO add custom code on component opening
    }

    @Override
    public void componentClosed() {
        // TODO add custom code on component closing
    }

    public void load() {
        explorerManager.setRootContext(createLogicalView());
    }
    private Node root;

    public Node createLogicalView() {
        final String features = (String) Config.getValue("features");
        if (features != null && !features.isEmpty()) {
            final String[] featureList = features.split(" ");
            if (featureList.length == 1) {
                UserExtensionManager.getInstance().setMode(featureList[0]);
                switch (featureList[0]) {
                    case "report-editor":
                        this.setDisplayName("Used-Defined Reports");
                        return root = new ReportsNode();
                    case "role-editor":
                        this.setDisplayName("Used-Defined Roles");
                        return root = new UserRolesNode();
                    case "msdl-editor":
                        this.setDisplayName("Used-Defined MSDLs");
                        return root = new MsdlSchemesNode();

                }

            } else {
                UserExtensionManager.getInstance().setMode("");
            }
        }
        this.setDisplayName("Used-Defined Definitions");
        return root = new UserExtensionsNode();
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p) {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }

    @Override
    public ExplorerManager getExplorerManager() {
        return explorerManager;
    }

    private Node findPath(final Node parent, final RadixObject target) {
        final Class<? extends RadixObject> targetClass = target.getClass();

        // lokup all for AdsEditorPageNode, it contains link and page.
        final RadixObject nodeObject = parent.getLookup().lookup(targetClass);
        if (nodeObject == target) {
            return parent;
        }

        // impossible to place in findPath(root, target), because root is not branch node, but ProjectsNode
        final Branch branch = parent.getLookup().lookup(Branch.class);
        if (branch != null && !branch.isParentOf(target)) {
            return null;
        }

        final Node[] childNodes = parent.getChildren().getNodes();

        for (RadixObject curObject = target; curObject != null; curObject = curObject.getContainer()) {
            for (Node childNode : childNodes) {

                final RadixObject childObject = childNode.getLookup().lookup(curObject.getClass());
                if (childObject == curObject) {
                    return findPath(childNode, target);
                }
            }
        }

        // for method in group (method displayed in group but group is separate object and not container for method).
        for (Node childNode : childNodes) {
            final Node result = findPath(childNode, target);
            if (result != childNode) {
                return result;
            }
        }

        return parent;
    }

    @Override
    public Node findPath(final Node root, final Object target) {
        return Children.MUTEX.writeAccess(new Mutex.Action<Node>() {
            @Override
            public Node run() {
                RadixObject radixObject = null;

                if (target instanceof FileObject) {
                    final FileObject fileObject = (FileObject) target;
                    radixObject = RadixFileUtil.getLastSelectedRadixObject(fileObject);
                    if (radixObject == null) {
                        radixObject = RadixFileUtil.findRadixObject(fileObject);
                    }
                } else if (target instanceof RadixObject) {
                    radixObject = (RadixObject) target;
                }

                if (radixObject == null) {
                    return null;
                }

                for (RadixObject ro = radixObject; ro != null; ro = ro.getContainer()) {
                    if (ro instanceof AdsLocalizingBundleDef) {
                        final AdsLocalizingBundleDef bundle = (AdsLocalizingBundleDef) ro;
                        radixObject = bundle.findBundleOwner();
                    }
                }

                restoreIfHidden(radixObject);

                return findPath(root, radixObject);
            }
        });

    }

    private void restoreIfHidden(final RadixObject target) {
        Node node = findPath(root, target);
        Restorable restorable;
        while (node != null) {
            restorable = node.getLookup().lookup(Restorable.class);
            if (restorable != null) {
                restorable.restore();
            }
            node = node.getParentNode();
        }
    }
}
