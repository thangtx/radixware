/*
 * Copyright (c) 2008-2015, Compass Plus Limited. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. This Source Code is distributed
 * WITHOUT ANY WARRANTY; including any implied warranties but not limited to
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * Mozilla Public License, v. 2.0. for more details.
 */

package org.radixware.kernel.designer.environment.actions.dialogs;

import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.util.LinkedList;
import java.util.List;
import javax.swing.Icon;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.ListCellRenderer;
import javax.swing.ListModel;
import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileView;
import org.radixware.kernel.common.defs.RadixObjectIcon;
import org.radixware.kernel.common.utils.dist.DistributionIcon;
import org.radixware.kernel.common.utils.dist.DistributionUtils;
import org.radixware.kernel.common.utils.dist.DistributionUtils.UpgradeInfo;
import org.radixware.kernel.designer.common.dialogs.utils.DialogUtils;


public class ConfigureUpgradeCompatibilityCheck extends javax.swing.JPanel {

    /** Creates new form ConfigureUpgradeCompatibilityCheck */
    private final FileList fileList = new FileList();
    private final ListCellRenderer renderer = new ListCellRenderer() {

        final JLabel label = new JLabel();

        {
            label.setOpaque(true);
        }

        @Override
        public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
            label.setText(value.toString());

            if (value instanceof FileInfo) {
                FileInfo info = (FileInfo) value;
                switch (info.info.upgradeKind) {
                    case PATCH:
                        label.setIcon(DistributionIcon.PATCH.getIcon());
                        break;
                    case UPGRADE:
                        label.setIcon(DistributionIcon.DISTRIBUTIVE.getIcon());
                        break;
                    default:
                        label.setIcon(RadixObjectIcon.UNKNOWN.getIcon());
                }
            }
            return label;
        }
    };

    public ConfigureUpgradeCompatibilityCheck() {
        initComponents();
        lstFiles.setCellRenderer(renderer);
        lstFiles.setModel(fileList);
        lstFiles.getSelectionModel().addListSelectionListener(new ListSelectionListener() {

            @Override
            public void valueChanged(ListSelectionEvent e) {
                updateState();
            }
        });
        btAddFile.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                addFile();
            }
        });
        btRemoveFile.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                removeFile();
            }
        });
        btClearFiles.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                clearFiles();
            }
        });
        updateState();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        lstFiles = new javax.swing.JList();
        btAddFile = new javax.swing.JButton();
        btRemoveFile = new javax.swing.JButton();
        btClearFiles = new javax.swing.JButton();

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(org.openide.util.NbBundle.getMessage(ConfigureUpgradeCompatibilityCheck.class, "ConfigureUpgradeCompatibilityCheck.jPanel1.border.title"))); // NOI18N

        jScrollPane1.setViewportView(lstFiles);

        btAddFile.setText(org.openide.util.NbBundle.getMessage(ConfigureUpgradeCompatibilityCheck.class, "ConfigureUpgradeCompatibilityCheck.btAddFile.text")); // NOI18N

        btRemoveFile.setText(org.openide.util.NbBundle.getMessage(ConfigureUpgradeCompatibilityCheck.class, "ConfigureUpgradeCompatibilityCheck.btRemoveFile.text")); // NOI18N

        btClearFiles.setText(org.openide.util.NbBundle.getMessage(ConfigureUpgradeCompatibilityCheck.class, "ConfigureUpgradeCompatibilityCheck.btClearFiles.text")); // NOI18N

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 335, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(btRemoveFile, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btAddFile, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btClearFiles, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 203, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel1Layout.createSequentialGroup()
                        .addComponent(btAddFile)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btRemoveFile)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btClearFiles)))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btAddFile;
    private javax.swing.JButton btClearFiles;
    private javax.swing.JButton btRemoveFile;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JList lstFiles;
    // End of variables declaration//GEN-END:variables

    private static class FileInfo {

        File file;
        DistributionUtils.UpgradeInfo info;

        public FileInfo(File file, UpgradeInfo info) {
            this.file = file;
            this.info = info;
        }

        @Override
        public String toString() {
            return info.getShortDescription();
        }

        @Override
        public boolean equals(Object o) {
            if (super.equals(o)) {
                return true;
            }
            if (o instanceof FileInfo) {
                return file.equals(((FileInfo) o).file);
            } else {
                return false;
            }
        }

        @Override
        public int hashCode() {
            int hash = 5;
            hash = 59 * hash + (this.file != null ? this.file.hashCode() : 0);
            hash = 59 * hash + (this.info != null ? this.info.hashCode() : 0);
            return hash;
        }
    }

    private static class FileList implements ListModel {

        List<FileInfo> files = new LinkedList<FileInfo>();
        private final List<ListDataListener> listeners = new LinkedList<ListDataListener>();

        @Override
        public int getSize() {
            return files.size();
        }

        @Override
        public Object getElementAt(int index) {
            return files.get(index);
        }

        @Override
        public void addListDataListener(ListDataListener l) {
            synchronized (listeners) {
                listeners.add(l);
            }
        }

        @Override
        public void removeListDataListener(ListDataListener l) {
            synchronized (listeners) {
                listeners.remove(l);
            }
        }

        private void fireChange() {
            synchronized (listeners) {
                ListDataEvent e = new ListDataEvent(this, ListDataEvent.CONTENTS_CHANGED, 0, getSize());
                for (ListDataListener l : listeners) {
                    l.contentsChanged(e);
                }
            }
        }

        void remove(FileInfo file) {
            if (files.remove(file)) {
                fireChange();
            }
        }

        void add(FileInfo file) {
            if (!files.contains(file)) {
                files.add(file);
                fireChange();
            }
        }

        void clear() {
            files.clear();
            fireChange();
        }
    }
    private int processsPhase = 0;

    private FileInfo currentFile() {
        if (fileList.getSize() > 0) {
            int index = lstFiles.getSelectedIndex();
            if (index >= 0 && index < fileList.getSize()) {
                return (FileInfo) fileList.getElementAt(index);
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    private List<FileInfo> files() {
        return fileList.files;
    }

    private void updateState() {
        btAddFile.setEnabled(processsPhase == 0);
        btRemoveFile.setEnabled(processsPhase == 0 && currentFile() != null);
        btClearFiles.setEnabled(processsPhase == 0 && !files().isEmpty());
    }
    private String lastSelectedDirPath = null;

    private void addFile() {
        if (processsPhase == 0) {
            JFileChooser chooser = new JFileChooser(lastSelectedDirPath);
            chooser.addChoosableFileFilter(new FileFilter() {

                @Override
                public boolean accept(File f) {
                    return f.isDirectory() || (f.getName().endsWith(".zip") && DistributionUtils.getUpgradeFileDescription(f) != DistributionUtils.INVALID_UPGRADE);
                }

                @Override
                public String getDescription() {
                    return "RadixWare Upgrade Files";
                }
            });
            chooser.setFileView(new FileView() {

                @Override
                public String getDescription(File f) {
                    if (f.isFile() && f.getName().endsWith(".zip")) {
                        DistributionUtils.UpgradeInfo info = DistributionUtils.getUpgradeFileDescription(f);
                        if (info != DistributionUtils.INVALID_UPGRADE) {
                            return info.getShortDescription();
                        }
                        return super.getDescription(f);
                    } else {
                        return super.getDescription(f);
                    }
                }

                @Override
                public Icon getIcon(File f) {
                    if (f.isFile() && f.getName().endsWith(".zip")) {
                        DistributionUtils.UpgradeInfo info = DistributionUtils.getUpgradeFileDescription(f);
                        switch (info.upgradeKind) {
                            case PATCH:
                                return DistributionIcon.PATCH.getIcon();
                            case UPGRADE:
                                return DistributionIcon.DISTRIBUTIVE.getIcon();
                            default:
                                return super.getIcon(f);
                        }
                    } else {
                        return super.getIcon(f);
                    }
                }
            });
            if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
                File file = chooser.getSelectedFile();
                if (file != null && file.isFile()) {
                    DistributionUtils.UpgradeInfo info = DistributionUtils.getUpgradeFileDescription(file);
                    if (info != DistributionUtils.INVALID_UPGRADE) {
                        FileInfo fileInfo = new FileInfo(file, info);
                        fileList.add(fileInfo);
                        int index = fileList.files.indexOf(fileInfo);
                        if (index >= 0) {
                            lstFiles.setSelectedIndex(index);
                        }
                    } else {
                        DialogUtils.messageError("File " + file.getPath() + " is not valid RadixWare upgrade package");
                    }
                }
                if (file != null) {
                    lastSelectedDirPath = file.getParent();
                }
                updateState();
            }
        }
    }

    private void removeFile() {
        if (processsPhase == 0) {
            FileInfo current = currentFile();
            if (current != null) {
                fileList.remove(current);
            }
            int index = lstFiles.getSelectedIndex();
            if (index >= fileList.getSize()) {
                index = fileList.getSize();
            }
            if (index >= 0) {
                lstFiles.setSelectedIndex(index);
            }
            updateState();
        }
    }

    private void clearFiles() {
        if (processsPhase == 0) {
            fileList.clear();
            updateState();
        }
    }

    public List<File> getFiles() {
        List<File> files = new LinkedList<File>();
        for (FileInfo info : fileList.files) {
            files.add(info.file);
        }
        return files;
    }
}
