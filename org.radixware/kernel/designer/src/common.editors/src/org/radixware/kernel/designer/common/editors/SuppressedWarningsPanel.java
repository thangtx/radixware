/*
 * Copyright (c) 2008-2015, Compass Plus Limited. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. This Source Code is distributed
 * WITHOUT ANY WARRANTY; including any implied warranties but not limited to
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * Mozilla Public License, v. 2.0. for more details.
 */

package org.radixware.kernel.designer.common.editors;

import java.awt.Image;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import javax.swing.SwingUtilities;

import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
import org.eclipse.jdt.internal.compiler.util.HashtableOfInt;
import org.openide.explorer.ExplorerManager;
import org.openide.explorer.view.CheckableNode;
import org.openide.explorer.view.OutlineView;
import org.openide.nodes.AbstractNode;
import org.openide.nodes.Children;
import org.openide.nodes.Node;
import org.radixware.kernel.common.check.RadixProblem;
import org.radixware.kernel.common.defs.RadixObject;
import org.radixware.kernel.common.defs.ads.AdsDefinition;
import org.radixware.kernel.common.enums.EEventSeverity;
import org.radixware.kernel.common.resources.RadixWareIcons;


class SuppressedWarningsPanel extends javax.swing.JPanel implements ExplorerManager.Provider {

    /**
     * Creates new form AdjustAccessModePanel
     */
    public SuppressedWarningsPanel() {
        initComponents();
        panel.add(beanView);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        panel = new javax.swing.JPanel();

        panel.setLayout(new java.awt.BorderLayout());

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(panel, javax.swing.GroupLayout.DEFAULT_SIZE, 391, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(panel, javax.swing.GroupLayout.DEFAULT_SIZE, 232, Short.MAX_VALUE)
                .addGap(56, 56, 56))
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel panel;
    // End of variables declaration//GEN-END:variables

    private class TreeView extends OutlineView {

        public TreeView() {
            super();
            getOutline().setRootVisible(false);
            getOutline().setShowGrid(false);
            getOutline().setRowSelectionAllowed(true);
            getOutline().setColumnHidingAllowed(false);
            getOutline().getColumnModel().getColumn(0).setHeaderValue("");
        }

        public void nodeSelected() {
            getOutline().tableChanged(null);
            getOutline().getColumnModel().getColumn(0).setHeaderValue("");
        }
    }
    private final transient TreeView beanView = new TreeView();
    private transient final ExplorerManager manager = new ExplorerManager();

    private static class PartNode extends AbstractNode {

        public PartNode(Children children) {
            super(children);
        }
    }

    private static class PartNodeChildren extends Children.Array {

        public PartNodeChildren(List<Node> children) {
            super(children);
        }
    }

    private static class ObjectNode extends AbstractNode {

        RadixObject obj;

        public ObjectNode(RadixObject obj, Children children) {
            super(children);
            this.obj = obj;
        }

        @Override
        public Image getIcon(final int type) {
            return obj.getIcon().getImage();
        }

        @Override
        public Image getOpenedIcon(final int type) {
            return getIcon(type);
        }

        @Override
        public String getShortDescription() {
            return obj.getQualifiedName();
        }

        @Override
        public String getHtmlDisplayName() {
            return obj.getName();
        }
    }

    private static class WarningNode extends AbstractNode implements CheckableNode {

        private RadixObject object;
        private int code;
        private String message;
        private boolean isSelected = true;
        private boolean isCompilerWarning = false;

        private WarningNode(RadixObject object, int code, String message) {
            super(Children.LEAF);
            this.object = object;
            this.code = code;
            this.message = message;
        }

        @Override
        public boolean isCheckable() {
            return true;
        }

        @Override
        public boolean isCheckEnabled() {
            return true;
        }

        @Override
        public Boolean isSelected() {
            return isSelected;
        }

        @Override
        public void setSelected(final Boolean selected) {
            isSelected = selected.booleanValue();
        }

        @Override
        public Image getIcon(final int type) {
            return RadixWareIcons.EVENT_LOG.getForSeverity(EEventSeverity.WARNING).getImage();
        }

        @Override
        public Image getOpenedIcon(final int type) {
            return getIcon(type);
        }

        @Override
        public String getShortDescription() {
            return message;
        }

        @Override
        public String getHtmlDisplayName() {
            return message;
        }
    }

    private static class ItemNodeChildren extends Children.Array {

        public ItemNodeChildren(List<Node> children) {
            super(children);
        }
    }

    private Node fillDef(RadixObject root, Map<RadixObject, List<RadixObject>> children) {

        final List<Node> nodes = new LinkedList<>();

        final RadixProblem.WarningSuppressionSupport suppress = root.getWarningSuppressionSupport(false);
        if (suppress != null) {
            final int[] codes = suppress.getSuppressedWarnings();
            if (codes != null && codes.length > 0) {

                final List<Node> warnings = new LinkedList<>();

                for (int i = 0; i < codes.length; i++) {
                    warnings.add(new WarningNode(root, codes[i], RadixProblem.getProblemDescription(root, codes[i])));
                }

                final PartNode partNode = new PartNode(new ItemNodeChildren(warnings));
                nodes.add(partNode);
                partNode.setDisplayName("RadixWare Warnings");

            }

        }
        if (root instanceof AdsDefinition) {
            final int[] compilerWarnings = ((AdsDefinition) root).getCompilerWarnings();
            if (compilerWarnings != null && compilerWarnings.length > 0) {
                final List<Node> warnings = new LinkedList<>();

                for (int i = 0; i < compilerWarnings.length; i++) {
                    final HashtableOfInt messages = DefaultProblemFactory.loadMessageTemplates(Locale.getDefault());
                    String message = null;
                    int id = ((compilerWarnings[i]+1) & 0xFFFFFF);
                    if (messages.containsKey(id)) {
                        message = String.valueOf(messages.get(id));
                    }
                    if (message == null || message.isEmpty()) {
                        message = String.valueOf(id);
                    }
                    WarningNode node = new WarningNode(root, compilerWarnings[i], message);
                    node.isCompilerWarning = true;
                    warnings.add(node);
                }

                final PartNode partNode = new PartNode(new ItemNodeChildren(warnings));
                nodes.add(partNode);
                partNode.setDisplayName("Compiler Warnings");

            }
        }

        List<RadixObject> ccc = children.get(root);
        if (ccc != null) {
            for (RadixObject obj : ccc) {
                Node n = fillDef(obj, children);
                nodes.add(n);
            }
        }

        return new ObjectNode(root, new ItemNodeChildren(nodes));
    }

    private Node fillDef(RadixObject root, List<RadixObject> children) {

        final List<RadixObject> path = new LinkedList<RadixObject>();
        final Map<RadixObject, List<RadixObject>> nodes = new HashMap<RadixObject, List<RadixObject>>();
        for (RadixObject c : children) {
            path.clear();
            RadixObject obj = c;
            while (obj != null && obj != root) {
                path.add(obj);
                obj = obj.getOwnerForQualifedName();
            }
            RadixObject cr = root;
            for (int i = path.size() - 1; i >= 0; i--) {
                obj = path.get(i);
                List<RadixObject> ccc = nodes.get(cr);
                if (ccc == null) {
                    ccc = new LinkedList<RadixObject>();
                    nodes.put(cr, ccc);
                }
                if (!ccc.contains(obj)) {
                    ccc.add(obj);
                }
                cr = obj;
            }
        }
        return fillDef(root, nodes);
    }

    /**
     * Creates new form ChooseClassMembersPanel
     */
    @Override
    public ExplorerManager getExplorerManager() {
        return manager;
    }

    public void open(final RadixObject def) {
        if (!def.isInBranch()) {
            return;
        }
        WarningsList list = new WarningsList() {
            @Override
            public void acceptSuppressers(final List<RadixObject> objects) {
                SwingUtilities.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        manager.setRootContext(fillDef(def, objects));
                    }
                });
            }
        };
        list.explore(def);

    }

    public void apply() {
        processNodes(manager.getRootContext());
    }

    private void processNodes(Node node) {
        if (node instanceof WarningNode) {
            WarningNode wn = (WarningNode) node;
            if (!wn.isSelected()) {
                if (wn.isCompilerWarning) {
                    ((AdsDefinition) wn.object).removeCompilerWarning(wn.code);
                } else {
                    RadixProblem.WarningSuppressionSupport support = wn.object.getWarningSuppressionSupport(false);
                    if (support != null) {
                        support.suppressWarnings(wn.code, false);
                    }
                }
            }
        }
        Node[] children = node.getChildren().getNodes();
        if (children != null) {
            for (Node c : children) {
                processNodes(c);
            }
        }
    }
}
