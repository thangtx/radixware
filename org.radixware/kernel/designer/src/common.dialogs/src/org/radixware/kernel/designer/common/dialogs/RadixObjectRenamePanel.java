/*
 * Copyright (c) 2008-2015, Compass Plus Limited. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. This Source Code is distributed
 * WITHOUT ANY WARRANTY; including any implied warranties but not limited to
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * Mozilla Public License, v. 2.0. for more details.
 */
package org.radixware.kernel.designer.common.dialogs;

import java.io.File;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import org.netbeans.api.progress.ProgressUtils;
import org.radixware.kernel.common.defs.Module;
import org.radixware.kernel.common.defs.RadixObject;
import org.radixware.kernel.common.enums.ERepositoryBranchType;
import org.radixware.kernel.common.repository.Branch;
import org.radixware.kernel.common.svn.RadixSvnException;
import org.radixware.kernel.common.svn.SVN;
import org.radixware.kernel.common.svn.SVNRepositoryAdapter;
import org.radixware.kernel.common.svn.client.ISvnFSClient;
import org.radixware.kernel.common.svn.client.SvnPath;
import org.radixware.kernel.common.utils.FileUtils;
import org.radixware.kernel.common.utils.Utils;
import org.radixware.kernel.designer.common.dialogs.utils.DialogUtils;
import org.radixware.kernel.designer.common.dialogs.utils.ModalDisplayer;
import org.radixware.kernel.designer.common.dialogs.utils.NameAcceptorFactory;
import org.radixware.kernel.designer.common.general.filesystem.RadixCoreSvnUtils;

public class RadixObjectRenamePanel extends JPanel {

    private final RadixObject radixObject;

    private RadixObjectRenamePanel(RadixObject radixObject) {
        this.radixObject = radixObject;
        initComponents();
        panel.setCurrentName(radixObject.getName());
        panel.setNameAcceptor(NameAcceptorFactory.newAcceptorForRename(radixObject));
        if (radixObject instanceof Module) {
            Branch b = radixObject.getBranch();
            if (b != null && b.getType() == ERepositoryBranchType.PATCH) {
                panel.setEnabled(false);
            }
        }
    }

    protected RadixObject getRadixObject() {
        return radixObject;
    }

    @Override
    public void requestFocus() {
        super.requestFocus();
        panel.requestFocusInWindow();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        panel = new org.radixware.kernel.designer.common.dialogs.components.NameEditPanel();
        jLabel1 = new javax.swing.JLabel();
        stateDisplayer1 = new org.radixware.kernel.designer.common.dialogs.components.state.StateDisplayer();

        setMinimumSize(new java.awt.Dimension(0, 50));

        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(RadixObjectRenamePanel.class, "DefinitionRenameDialog.jLabel1.text")); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(12, 12, 12)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(stateDisplayer1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(panel, javax.swing.GroupLayout.DEFAULT_SIZE, 406, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(panel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(stateDisplayer1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(39, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private org.radixware.kernel.designer.common.dialogs.components.NameEditPanel panel;
    private org.radixware.kernel.designer.common.dialogs.components.state.StateDisplayer stateDisplayer1;
    // End of variables declaration//GEN-END:variables

    public static void renameRadixObject(final RadixObject radixObject) {
        final RadixObjectRenamePanel renamePanel = new RadixObjectRenamePanel(radixObject);

        final ModalDisplayer modalDisplayer = new ModalDisplayer(renamePanel, "Rename " + radixObject.getTypeTitle());

        renamePanel.panel.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                modalDisplayer.getDialogDescriptor().setValid(renamePanel.panel.isComplete());
            }
        });

        if (modalDisplayer.showModal()) {
            final String newName = renamePanel.panel.getCurrentName();

            renameRadixObject(radixObject, newName);
        }
    }

    public static void renameRadixObject(final RadixObject radixObject, String newName) {
        final String oldName = radixObject.getName();
        if (!Utils.equals(oldName, newName) && checkBeforeModuleRename(radixObject, newName)) {

            if (radixObject instanceof Module) {
                renameModule((Module) radixObject, newName);
            } else {
                radixObject.setName(newName);
            }
        }
    }

    private static void renameModule(final Module module, final String newName) {
//        final String oldName = module.getName();
//        try {
//            if (module.isUserExtension()) {
//                module.setName(newName);
//                return;
//            }
//            final SVNRepositoryAdapter repository = RadixCoreSvnUtils.getRepository(module);
//            final ISvnFSClient fsClient = RadixCoreSvnUtils.getFsClient(module);
//            if (repository == null) {
//                DialogUtils.messageError("Failure to rename module");
//                return;
//            }
//
//            try {
//
//                final long letestRevision = repository.getLatestRevision();
//                final String segmentUrl = SVN.getFileUrl(fsClient,module.getDirectory().getParentFile());
//                final String currModulePath = SvnPath.getRelativePath(repository.getLocation(), SvnPath.append(segmentUrl, oldName));
//                final boolean exists = SVN.isExists(repository, currModulePath);
//
//                if (exists) {
//
//                    final File oldFile = module.getDirectory();
//                    final File newFile = new File(module.getDirectory().getParentFile(), newName);
//
//                    ProgressUtils.showProgressDialogAndRun(new Runnable() {
//                        @Override
//                        public void run() {
//
//                            try {
//
//                                if (RadixCoreSvnUtils.hasLocalModifications(fsClient, oldFile, letestRevision)) {
//                                    DialogUtils.messageError("You should commit your local changes before rename");
//                                    return;
//                                }
//
//                                if (!RadixCoreSvnUtils.isUpToDate(fsClient, oldFile, letestRevision)) {
//                                    DialogUtils.messageError("You should update module before rename");
//                                    return;
//                                }
//
//                                SVN.update(fsClient, oldFile);
//
//                                module.setName(newName);
//
//                                final File[] files = new File[]{oldFile, newFile};
//
//                                RadixCoreSvnUtils.refreshStatus(files);
//                                SVN.commit(fsClient, files, newName);
//                                RadixCoreSvnUtils.refreshStatus(files);
//
//                            } catch (final ISvnFSClient.SvnFsClientException ex) {
//                                SwingUtilities.invokeLater(new Runnable() {
//                                    @Override
//                                    public void run() {
//                                        DialogUtils.messageError(ex);
//                                    }
//                                });
//                            }
//                        }
//                    }, "Rename module...");
//                } else {
                    module.setName(newName);
//                }
//            } finally {
//                repository.close();
//            }
//
//        } catch (RadixSvnException e) {
//            DialogUtils.messageError(e);
//        }
    }

    private static boolean checkBeforeModuleRename(RadixObject radixObject_, String newName) { // RADIX-6080 
        if (!(radixObject_ instanceof Module)) {
            return true;
        }
        File parent = radixObject_.getFile().getParentFile().getParentFile();
        String newPath = parent.getAbsolutePath() + '/' + newName;
        File newFile = new File(newPath);
        if (newFile.exists()) {
            if (DialogUtils.messageConfirmation((newFile.isDirectory() ? "Directory \'" : "File \'") + newPath + "\' already exists. Overwrite?")) {
                if (!FileUtils.deleteFileOrDirectory(newFile)) {
                    DialogUtils.messageError("Failure to replace.");
                    return false;
                }
            }
        }
        return true;
    }
}
